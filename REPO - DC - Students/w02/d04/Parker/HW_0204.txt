1.       Explain what a reference is and how it relates to variable assignmentA variable is a named storage location that holds a value. It is named with an identifier, possibly preceded by a sigil (a symbol denoting the variable’s scope).When the name of a variable appears somewhere other than the left?hand side of an assignment expression it is a variable reference which evaluates to the variable’s value.2.       Describe the two forms of variable assignment used by programming languagesMultiple Assignment 1.  var1, var2, var3 = 10, 20, 302. 3.   puts var1           #=>var1 is now 104. 5.   puts var2           #=>var2 is now 20,var3...etcConditional Assignment 1.   x = find_something() #=>nil3.       Perform basic operations on strings and numbers$: sum = 18 + 5  $: 23 4.       Manipulate strings using concatenation & interpolationThe difference between + and << is that << changes the object on its left hand side, and + doesn't.irb(main):001:0> s = 'a'=> "a"irb(main):002:0> s + 'b'=> "ab"irb(main):003:0> s=> "a"irb(main):004:0> s << 'b'=> "ab"irb(main):005:0> s=> "ab"5.       Use Ruby case statementssimple case statement works, we test on a condition that we give to a case statement, we then walk through a set of possible matches each of which is contained in a when statement e.g.print "Enter your grade: "grade = gets.chompcase gradewhen "A"  puts 'Well done!'when "B"  puts 'Try harder!'when "C"  puts 'You need help!!!'else  puts "You just making it up!"end6.       Define the terms `arguments` and `parameters`a parameter is part of the function/procedure/method signature and an argument is the actual value supplied at run-time and/or call-site for the parameter.7.   Explain the difference between a string and a symbol and when you would use eachThe most important thing about symbols is that they are immutable - this means that it will never have its value changed. Also, symbols are instantiated faster than strings and some methods are also faster, like comparing two symbols.In Ruby implementation, the fact that a symbol is immutable allows ruby use the same object every time you references the symbol, saving memory. Also it is important to know that a symbol, once instantiated, never have the memory free again by the interpreter, which is often the root cause for memory leaks when used wrongly. This means that every time you want to access a symbol, you can just go to memory and get it if it already exists, which is way less expansive than instantiating a string. You can get a list all symbols that are already instantiated with the command Symbol.all_symbols.8.   Explain what yield does in the context of a blockA method can then invoke an associated block one or more time using the Ruby yield statement. Thus any method that wants to take a block as a parameter can use the yield keyword to execute the block at any time. 9.   Explain the difference between `.each` and `.map` and when you would use each oneeach is different from map and collect, but map and collect are the same (technically map is an alias for collect, but in my experience map is used a lot more frequently).each performs the enclosed block for each element in the (Enumerable) receiver:[1,2,3,4].each {|n| puts n*2}# Outputs:# 2# 4# 6# 8map and collect produce a new Array containing the results of the block applied to each element of the receiver:[1,2,3,4].map {|n| n*2}# => [2,4,6,8]There's also map! / collect! defined on Arrays; they modify the receiver in place:a = [1,2,3,4]a.map {|n| n*2} # => [2,4,6,8]puts a.inspect  # prints: "[1,2,3,4]"a.map! {|n| n+1}puts a.inspect  # prints: "[2,3,4,5]"10.   Use built in Ruby methods to enumerate over a collectioncreate a class and define constants in it :class Color  BLUE=1  RED=2  GREEN=3  YELLOW=4  ORANGE=5  PURPLE=6endpaint_the_car(Color::YELLOW)If you need a more elaborate enum, that is, if you want to iterate through every items like if it was a collection, you’ll have some more work to do (but not that much) :class Color    def Color.add_item(key,value)        @hash ||= {}        @hash[key]=value    end    def Color.const_missing(key)        @hash[key]    end        def Color.each        @hash.each {|key,value| yield(key,value)}    end    Color.add_item :BLUE, 1    Color.add_item :RED, 2    Color.add_item :YELLOW, 3end#That's it! We can now use our enum :my_color = Color::RED if some_condition#And we can loopColor.each do |key,value|  do_something_with_value(value)end